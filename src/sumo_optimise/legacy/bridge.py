"""Bridge utilities that delegate to the legacy v1.2.11 converter."""
from __future__ import annotations

import importlib.util
import shutil
import sys
from contextlib import contextmanager
from dataclasses import dataclass
from pathlib import Path
from tempfile import TemporaryDirectory
from types import ModuleType
from typing import Iterator


LEGACY_SCRIPT_PATH = Path("data/legacy(v1.2)/plainXML_converter_0927_1.2.11.py").resolve()


@dataclass(slots=True)
class LegacyPlainXML:
    """PlainXML artefacts generated by the legacy converter."""

    nodes_xml: str
    edges_xml: str
    connections_xml: str
    outdir: Path


def _load_legacy_module() -> ModuleType:
    spec = importlib.util.spec_from_file_location("_legacy_plainxml", LEGACY_SCRIPT_PATH)
    if spec is None or spec.loader is None:  # pragma: no cover - defensive
        raise ImportError(f"unable to load legacy script from {LEGACY_SCRIPT_PATH}")
    module = importlib.util.module_from_spec(spec)
    sys.modules.setdefault(spec.name, module)
    spec.loader.exec_module(module)
    return module


@contextmanager
def _temporary_directory(base: Path | None) -> Iterator[Path]:
    if base is not None:
        base.mkdir(parents=True, exist_ok=True)
        yield base
        return
    with TemporaryDirectory() as tmp:
        yield Path(tmp)


def run_legacy_plainxml(
    *,
    spec_path: Path,
    schema_path: Path,
    output_dir: Path | None,
    keep_output: bool,
) -> LegacyPlainXML:
    """Execute the legacy converter and collect its PlainXML strings."""

    legacy = _load_legacy_module()

    def execute(work_base: Path) -> LegacyPlainXML:
        outdir = work_base if keep_output else work_base / "plainxml"
        if outdir.exists():
            shutil.rmtree(outdir)
        outdir.mkdir(parents=True, exist_ok=True)

        artifacts = legacy.BuildArtifacts(
            outdir=outdir,
            log_path=outdir / "build.log",
            nodes_path=outdir / "nodes.nod.xml",
            edges_path=outdir / "edges.edg.xml",
            connections_path=outdir / "connections.con.xml",
        )

        def ensure_output_directory_patch() -> object:
            return artifacts

        original_input = getattr(legacy, "INPUT_JSON_PATH", None)
        original_schema = getattr(legacy, "SCHEMA_JSON_PATH", None)
        original_ensure = legacy.ensure_output_directory
        original_netconvert = legacy.run_two_step_netconvert

        legacy.INPUT_JSON_PATH = spec_path
        legacy.SCHEMA_JSON_PATH = schema_path
        legacy.ensure_output_directory = ensure_output_directory_patch  # type: ignore[assignment]
        legacy.run_two_step_netconvert = lambda _: None  # type: ignore[assignment]
        try:
            legacy.main()
        finally:
            legacy.INPUT_JSON_PATH = original_input
            legacy.SCHEMA_JSON_PATH = original_schema
            legacy.ensure_output_directory = original_ensure
            legacy.run_two_step_netconvert = original_netconvert

        nodes_xml = artifacts.nodes_path.read_text(encoding="utf-8")
        edges_xml = artifacts.edges_path.read_text(encoding="utf-8")
        connections_xml = artifacts.connections_path.read_text(encoding="utf-8")
        return LegacyPlainXML(
            nodes_xml=nodes_xml,
            edges_xml=edges_xml,
            connections_xml=connections_xml,
            outdir=outdir,
        )

    with _temporary_directory(output_dir) as work_dir:
        return execute(work_dir)
